val generateHtmlDefinitions =
  taskKey[File]("Generate Definitions.scala file from HTML Living Standard")
generateHtmlDefinitions := {
  import com.gargoylesoftware.htmlunit.WebClient
  import com.gargoylesoftware.htmlunit.html.{HtmlPage, HtmlTable}
  import org.portablescala.sbtplatformdeps.PlatformDepsPlugin
  import org.portablescala.sbtplatformdeps.PlatformDepsPlugin.autoImport._

  import scala.collection.JavaConverters._
  import scala.meta._
  type InterfaceName = String
  type ElementName = String
  type PropertyName = String
  type AttributeName = String
  type TypeName = String

  final case class AttributeDefinition(
      interfacesByTagName: Map[ElementName, InterfaceName],
      interfacesByAttribute: Map[AttributeName, Seq[InterfaceName]]
  )
  val attributeDefinition: AttributeDefinition = {
    val webClient = new WebClient()
    try {
      webClient.getOptions.setJavaScriptEnabled(false)
      webClient.getOptions.setCssEnabled(false)
      val document = webClient.getPage[HtmlPage](
        "https://html.spec.whatwg.org/multipage/indices.html"
      )
      try {
        val interfacesByTagName = {
          for {
            tbody <- document
              .querySelector("#element-interfaces ~ table")
              .asInstanceOf[HtmlTable]
              .getBodies
              .asScala
              .view
            row <- tbody.getRows.asScala.view
            Seq(tagNameCell, interfaceCell) = row.getCells.asScala
            tagNameCode <- tagNameCell
              .getElementsByTagName("code")
              .asScala
              .view
          } yield tagNameCode.asNormalizedText -> interfaceCell
            .getElementsByTagName("code")
            .asScala
            .head
            .asNormalizedText
        }.toMap
        val interfacesByAttribute = {
          for {
            tbody <- document
              .getElementById("attributes-1")
              .asInstanceOf[HtmlTable]
              .getBodies
              .asScala
              .view ++
              document
                .querySelector("#attributes-1 ~ table")
                .asInstanceOf[HtmlTable]
                .getBodies
                .asScala
                .view
            row <- tbody.getRows.asScala.view
            interfaceName <-
              if (row.getCell(1).asNormalizedText == "HTML elements") {
                Seq("HTMLElement")
              } else {
                row
                  .getCell(1)
                  .getElementsByTagName("code")
                  .asScala
                  .view
                  .map { code =>
                    interfacesByTagName(code.asNormalizedText)
                  }
              }
          } yield row.getCell(0).asNormalizedText -> interfaceName
        }.groupBy(_._1).mapValues(_.map(_._2).distinct.toList)
        AttributeDefinition(interfacesByTagName, interfacesByAttribute)
      } finally {
        document.cleanUp()
      }
    } finally {
      webClient.close()
    }
  }

  val elementCases =
    for (
      (tagName, domInterface) <-
        attributeDefinition.interfacesByTagName
    ) yield {
      p"""
      case $tagName =>
        Type.of[${Type.Name(domInterface)}]
    """
    }
  val attributeCases =
    for (
      (attributeName, domInterfaces) <-
        attributeDefinition.interfacesByAttribute
    ) yield {
      p"""
        case $attributeName =>
          TypeRepr.of[E] <:< TypeRepr.of[${domInterfaces
        .map { domInterface => Type.Name(domInterface): Type }
        .reduce { (t1, t2) =>
          t"$t1 | $t2"
        }}]
      """
    }
  val geneatedAst = q"""
    package com.thoughtworks.binding.html {
      import org.scalajs.dom.*
      import scala.quoted.*
      import ScalaJsDomMissingTypes.*
      object Definitions {
        def findTypeByTagName(tagName: String)(implicit quotes: Quotes): Type[_ <: HTMLElement] = {
          (tagName : @scala.annotation.switch) match {
            ..case ${elementCases.toList}
            case _ =>
              Type.of[HTMLUnknownElement]
          }
        }
        def isValidAttribute[E](attributeName: String)(implicit elementType: Type[E], quotes: Quotes): Boolean = {
          import quotes.reflect.TypeRepr
          (attributeName : @scala.annotation.switch) match {
            ..case ${attributeCases.toList}
            case _ =>
              false
          }
        }
      }
    }
  """
  val file =
    (Compile / scalaSource).value / "com" / "thoughtworks" / "binding" / "html" / "Definitions.scala"
  val fileContent = Seq(
    "// Don't edit this file, because it is generated by `sbt generateHtmlDefinitions`",
    geneatedAst.syntax
  )
  IO.writeLines(file, fileContent)
  file
}
